<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>#124 Binary Tree Maximum Path Sum - HackerRank</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:Inter,sans-serif;background:#F5F8FA;line-height:1.6}code{font-family:monospace}.container{max-width:1000px;margin:0 auto;padding:24px}.header{background:#FFF;padding:16px 0;margin-bottom:24px;border-bottom:1px solid #ddd}.back-link{color:#00EA64;text-decoration:none;font-weight:600}.content{background:#FFF;padding:32px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,0.05)}.difficulty{display:inline-block;padding:4px 12px;background:rgba(244,67,54,0.12);color:#D32F2F;border-radius:4px;font-size:12px;font-weight:600}h1{font-size:28px;margin:12px 0}h2{font-size:20px;margin:24px 0 12px}h3{font-size:16px;margin:16px 0 8px}.tag{display:inline-block;padding:4px 12px;background:#EDF1F5;border-radius:4px;font-size:12px;margin-right:8px}.content-box{background:#F5F8FA;border-left:3px solid #00EA64;padding:16px;border-radius:4px;margin:12px 0}pre{background:#282c34;color:#abb2bf;padding:16px;border-radius:6px;overflow-x:auto;margin:12px 0}.code-tabs{display:flex;gap:8px;border-bottom:1px solid #ddd;margin:12px 0}.tab-btn{padding:8px 16px;background:none;border:none;border-bottom:2px solid transparent;cursor:pointer;font-weight:600}.tab-btn.active{color:#00EA64;border-bottom-color:#00EA64}.code-content{display:none}.code-content.active{display:block}.tip-box{background:linear-gradient(135deg,#00EA64 0%,#00C853 100%);color:white;padding:20px;border-radius:8px;margin:12px 0}ul{margin-left:24px}li{margin:8px 0}</style>
</head>
<body>
    <div class="header"><div class="container"><a href="../index.html" class="back-link">← 返回題目列表</a></div></div>
    <div class="container"><div class="content">
        <span class="difficulty">HARD</span>
        <h1>#124 Binary Tree Maximum Path Sum</h1>
        <div><span class="tag">Tree</span><span class="tag">DFS</span><span class="tag">Dynamic Programming</span><span class="tag">Binary Tree</span></div>
        
        <h2>題目描述</h2>
        <div class="content-box">
            <p>二元樹中的<strong>路徑</strong>被定義為一條從樹中任意節點出發，沿父節點-子節點連接，達到任意節點的序列。同一個節點在一條路徑序列中<strong>至多出現一次</strong>。該路徑<strong>至少包含一個</strong>節點，且不一定經過根節點。</p>
            <p><strong>路徑和</strong>是路徑中各節點值的總和。</p>
            <p>給你一個二元樹的根節點 root，返回其<strong>最大路徑和</strong>。</p>
        </div>
        
        <h2>範例</h2>
        <pre>範例 1:
輸入：root = [1,2,3]
        1
       / \
      2   3
輸出：6
解釋：最優路徑是 2 -> 1 -> 3，路徑和為 2 + 1 + 3 = 6

範例 2:
輸入：root = [-10,9,20,null,null,15,7]
         -10
         /  \
        9   20
           /  \
          15   7
輸出：42
解釋：最優路徑是 15 -> 20 -> 7，路徑和為 15 + 20 + 7 = 42</pre>
        
        <h2>解題思路</h2>
        <div class="content-box">
            <h3>後序遍歷 + 動態規劃</h3>
            <p><strong>關鍵觀察：</strong></p>
            <ul>
                <li>對於每個節點，最大路徑和可能包含：節點本身 + 左子樹貢獻 + 右子樹貢獻</li>
                <li>但返回給父節點時，只能選擇一條路徑（左或右）</li>
            </ul>
            <p><strong>算法步驟：</strong></p>
            <ol>
                <li>遞迴計算左右子樹的最大貢獻值</li>
                <li>如果貢獻值為負，則不選擇該子樹（設為 0）</li>
                <li>計算經過當前節點的最大路徑和：node.val + left_gain + right_gain</li>
                <li>更新全局最大值</li>
                <li>返回當前節點能提供給父節點的最大貢獻：node.val + max(left_gain, right_gain)</li>
            </ol>
            <p><strong>時間複雜度：</strong>O(n)<br><strong>空間複雜度：</strong>O(h)，h 為樹高</p>
        </div>
        
        <h2>程式碼實作</h2>
        <div class="code-tabs">
            <button class="tab-btn active" data-lang="python">Python</button>
            <button class="tab-btn" data-lang="cpp">C++</button>
            <button class="tab-btn" data-lang="java">Java</button>
        </div>
        
        <div class="code-content python active">
            <h3>Python 解法</h3>
            <pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        """
        後序遍歷 + 動態規劃
        
        時間複雜度：O(n)
        空間複雜度：O(h)
        """
        self.max_sum = float('-inf')
        
        def maxGain(node):
            """
            計算節點的最大貢獻值
            
            Returns:
                當前節點能提供給父節點的最大貢獻值
            """
            if not node:
                return 0
            
            # 遞迴計算左右子節點的最大貢獻值
            # 只有在最大貢獻值大於 0 時，才會選取對應子節點
            left_gain = max(maxGain(node.left), 0)
            right_gain = max(maxGain(node.right), 0)
            
            # 節點的最大路徑和取決於該節點的值與左右子節點的最大貢獻值
            price_newpath = node.val + left_gain + right_gain
            
            # 更新答案
            self.max_sum = max(self.max_sum, price_newpath)
            
            # 返回節點的最大貢獻值
            # 只能選擇左或右一條路徑
            return node.val + max(left_gain, right_gain)
        
        maxGain(root)
        return self.max_sum</code></pre>
        </div>
        
        <div class="code-content cpp">
            <h3>C++ 解法</h3>
            <pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int maxSum = INT_MIN;
        maxGain(root, maxSum);
        return maxSum;
    }
    
private:
    int maxGain(TreeNode* node, int& maxSum) {
        if (!node) return 0;
        
        // 遞迴計算左右子樹的最大貢獻值
        int leftGain = max(maxGain(node->left, maxSum), 0);
        int rightGain = max(maxGain(node->right, maxSum), 0);
        
        // 計算經過當前節點的最大路徑和
        int priceNewPath = node->val + leftGain + rightGain;
        
        // 更新答案
        maxSum = max(maxSum, priceNewPath);
        
        // 返回節點的最大貢獻值
        return node->val + max(leftGain, rightGain);
    }
};</code></pre>
        </div>
        
        <div class="code-content java">
            <h3>Java 解法</h3>
            <pre><code class="language-java">class Solution {
    private int maxSum = Integer.MIN_VALUE;
    
    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }
    
    private int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 遞迴計算左右子節點的最大貢獻值
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);
        
        // 節點的最大路徑和
        int priceNewPath = node.val + leftGain + rightGain;
        
        // 更新答案
        maxSum = Math.max(maxSum, priceNewPath);
        
        // 返回節點的最大貢獻值
        return node.val + Math.max(leftGain, rightGain);
    }
}</code></pre>
        </div>
        
        <h2>算法過程視覺化</h2>
        <div class="content-box">
            <pre>範例：root = [-10,9,20,null,null,15,7]

         -10
         /  \
        9   20
           /  \
          15   7

遞迴過程：

1. 節點 15：
   - left_gain = 0, right_gain = 0
   - path_sum = 15
   - 返回給父節點：15

2. 節點 7：
   - left_gain = 0, right_gain = 0
   - path_sum = 7
   - 返回給父節點：7

3. 節點 20：
   - left_gain = 15, right_gain = 7
   - path_sum = 20 + 15 + 7 = 42 ✓ (最大)
   - 返回給父節點：20 + max(15, 7) = 35

4. 節點 9：
   - left_gain = 0, right_gain = 0
   - path_sum = 9
   - 返回給父節點：9

5. 節點 -10：
   - left_gain = 9, right_gain = 35
   - path_sum = -10 + 9 + 35 = 34
   - 返回：-10 + max(9, 35) = 25

最大路徑和 = 42 (路徑：15 -> 20 -> 7)</pre>
        </div>
        
        <h2>關鍵理解</h2>
        <div class="content-box">
            <h3>為什麼要取 max(gain, 0)？</h3>
            <p>如果子樹的貢獻為負值，選擇該子樹會降低路徑和，所以我們選擇不經過該子樹（貢獻設為 0）。</p>
            
            <h3>為什麼返回 node.val + max(left, right)？</h3>
            <p>返回給父節點時，只能選擇一條路徑（左或右），不能同時選擇兩條，否則會形成分叉，不符合路徑定義。</p>
            
            <h3>節點值可以為負數</h3>
            <p>題目允許節點值為負數，所以初始化 max_sum = -∞，而不是 0。</p>
        </div>
        
        <h2>面試要點</h2>
        <div class="tip-box">
            <h3>解題技巧</h3>
            <ul>
                <li>使用後序遍歷（左右根）</li>
                <li>區分「經過節點的路徑和」vs「節點的貢獻值」</li>
                <li>負貢獻時選擇不走該路徑</li>
                <li>返回時只能選擇單邊路徑</li>
            </ul>
        </div>
        
        <div class="tip-box">
            <h3>常見錯誤</h3>
            <ul>
                <li>忘記處理負數貢獻</li>
                <li>返回值選擇了兩條路徑</li>
                <li>初始值設置不當（應為負無窮）</li>
                <li>混淆路徑和與貢獻值的概念</li>
            </ul>
        </div>
        
        <h2>相關題目</h2>
        <div class="content-box">
            <ul>
                <li><strong>Path Sum</strong>：判斷是否存在特定路徑和</li>
                <li><strong>Binary Tree Maximum Sum Path Between Two Leaves</strong>：限制路徑必須在葉節點間</li>
                <li><strong>Diameter of Binary Tree</strong>：計算樹的直徑（最長路徑）</li>
            </ul>
        </div>
    </div></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const lang = this.dataset.lang;
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));
                this.classList.add('active');
                document.querySelector(`.code-content.${lang}`).classList.add('active');
            });
        });
    </script>
</body>
</html>