<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>#76 Minimum Window Substring - HackerRank</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:Inter,sans-serif;background:#F5F8FA;line-height:1.6}code{font-family:monospace}.container{max-width:1000px;margin:0 auto;padding:24px}.header{background:#FFF;padding:16px 0;margin-bottom:24px;border-bottom:1px solid #ddd}.back-link{color:#00EA64;text-decoration:none;font-weight:600}.content{background:#FFF;padding:32px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,0.05)}.difficulty{display:inline-block;padding:4px 12px;background:rgba(244,67,54,0.12);color:#D32F2F;border-radius:4px;font-size:12px;font-weight:600}h1{font-size:28px;margin:12px 0}h2{font-size:20px;margin:24px 0 12px}h3{font-size:16px;margin:16px 0 8px}.tag{display:inline-block;padding:4px 12px;background:#EDF1F5;border-radius:4px;font-size:12px;margin-right:8px}.content-box{background:#F5F8FA;border-left:3px solid #00EA64;padding:16px;border-radius:4px;margin:12px 0}pre{background:#282c34;color:#abb2bf;padding:16px;border-radius:6px;overflow-x:auto;margin:12px 0}.code-tabs{display:flex;gap:8px;border-bottom:1px solid #ddd;margin:12px 0}.tab-btn{padding:8px 16px;background:none;border:none;border-bottom:2px solid transparent;cursor:pointer;font-weight:600}.tab-btn.active{color:#00EA64;border-bottom-color:#00EA64}.code-content{display:none}.code-content.active{display:block}.tip-box{background:linear-gradient(135deg,#00EA64 0%,#00C853 100%);color:white;padding:20px;border-radius:8px;margin:12px 0}ul{margin-left:24px}li{margin:8px 0}</style>
</head>
<body>
    <div class="header"><div class="container"><a href="../index.html" class="back-link">← 返回題目列表</a></div></div>
    <div class="container"><div class="content">
        <span class="difficulty">HARD</span>
        <h1>#76 Minimum Window Substring</h1>
        <div><span class="tag">Hash Table</span><span class="tag">String</span><span class="tag">Sliding Window</span></div>
        
        <h2>題目描述</h2>
        <div class="content-box">
            <p>給定字符串 s 和 t，找出 s 中包含 t 所有字符的最小子字符串。如果不存在符合條件的子字符串，則返回空字符串 ""。</p>
            <p><strong>注意：</strong>題目資料保證答案唯一。</p>
        </div>
        
        <h2>範例</h2>
        <pre>範例 1:
輸入：s = "ADOBECODEBANC", t = "ABC"
輸出："BANC"
解釋：最小窗口子串 "BANC" 包含 t 中的 'A'、'B'、'C'

範例 2:
輸入：s = "a", t = "a"
輸出："a"

範例 3:
輸入：s = "a", t = "aa"
輸出：""
解釋：t 中有兩個 'a'，但 s 中只有一個</pre>
        
        <h2>解題思路</h2>
        <div class="content-box">
            <h3>滑動窗口法</h3>
            <p><strong>核心思想：</strong>使用雙指針維護一個滑動窗口</p>
            <ol>
                <li>統計 t 中所有字符的出現次數</li>
                <li>使用右指針擴展窗口，直到包含所有 t 的字符</li>
                <li>使用左指針收縮窗口，找到最小窗口</li>
                <li>重複步驟 2-3，記錄最小窗口</li>
            </ol>
            <p><strong>時間複雜度：</strong>O(|s| + |t|)<br><strong>空間複雜度：</strong>O(|s| + |t|)</p>
        </div>
        
        <h2>程式碼實作</h2>
        <div class="code-tabs">
            <button class="tab-btn active" data-lang="python">Python</button>
            <button class="tab-btn" data-lang="cpp">C++</button>
            <button class="tab-btn" data-lang="java">Java</button>
        </div>
        
        <div class="code-content python active">
            <h3>Python 解法</h3>
            <pre><code class="language-python">from collections import Counter

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not s or not t:
            return ""
        
        # 統計 t 中字符出現次數
        dict_t = Counter(t)
        required = len(dict_t)  # 需要匹配的不同字符數
        
        # 窗口指針
        left, right = 0, 0
        
        # formed：當前窗口中已經匹配的字符種類數
        formed = 0
        window_counts = {}
        
        # 結果：(窗口長度, 左指針, 右指針)
        ans = float("inf"), None, None
        
        while right < len(s):
            # 擴展窗口
            char = s[right]
            window_counts[char] = window_counts.get(char, 0) + 1
            
            # 檢查是否完全匹配了某個字符
            if char in dict_t and window_counts[char] == dict_t[char]:
                formed += 1
            
            # 嘗試收縮窗口
            while left <= right and formed == required:
                char = s[left]
                
                # 更新最小窗口
                if right - left + 1 < ans[0]:
                    ans = (right - left + 1, left, right)
                
                # 移除左邊字符
                window_counts[char] -= 1
                if char in dict_t and window_counts[char] < dict_t[char]:
                    formed -= 1
                
                left += 1
            
            right += 1
        
        return "" if ans[0] == float("inf") else s[ans[1]:ans[2] + 1]</code></pre>
        </div>
        
        <div class="code-content cpp">
            <h3>C++ 解法</h3>
            <pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;climits&gt;
using namespace std;

class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map&lt;char, int&gt; target, window;
        
        // 統計 t 中字符
        for (char c : t) {
            target[c]++;
        }
        
        int left = 0, right = 0;
        int required = target.size();
        int formed = 0;
        int minLen = INT_MAX, minLeft = 0;
        
        while (right < s.length()) {
            char c = s[right];
            window[c]++;
            
            if (target.count(c) && window[c] == target[c]) {
                formed++;
            }
            
            while (left <= right && formed == required) {
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minLeft = left;
                }
                
                char c = s[left];
                window[c]--;
                if (target.count(c) && window[c] < target[c]) {
                    formed--;
                }
                left++;
            }
            
            right++;
        }
        
        return minLen == INT_MAX ? "" : s.substr(minLeft, minLen);
    }
};</code></pre>
        </div>
        
        <div class="code-content java">
            <h3>Java 解法</h3>
            <pre><code class="language-java">import java.util.*;

class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) {
            return "";
        }
        
        Map&lt;Character, Integer&gt; dictT = new HashMap&lt;&gt;();
        for (char c : t.toCharArray()) {
            dictT.put(c, dictT.getOrDefault(c, 0) + 1);
        }
        
        int required = dictT.size();
        int left = 0, right = 0;
        int formed = 0;
        Map&lt;Character, Integer&gt; windowCounts = new HashMap&lt;&gt;();
        
        int[] ans = {-1, 0, 0}; // {長度, 左, 右}
        
        while (right < s.length()) {
            char c = s.charAt(right);
            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);
            
            if (dictT.containsKey(c) && 
                windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
                formed++;
            }
            
            while (left <= right && formed == required) {
                c = s.charAt(left);
                
                if (ans[0] == -1 || right - left + 1 < ans[0]) {
                    ans[0] = right - left + 1;
                    ans[1] = left;
                    ans[2] = right;
                }
                
                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dictT.containsKey(c) && 
                    windowCounts.get(c).intValue() < dictT.get(c).intValue()) {
                    formed--;
                }
                
                left++;
            }
            
            right++;
        }
        
        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }
}</code></pre>
        </div>
        
        <h2>算法過程視覺化</h2>
        <div class="content-box">
            <pre>s = "ADOBECODEBANC", t = "ABC"
需要：A:1, B:1, C:1

步驟 1: [ADOBEC]ODEBANC
        left=0, right=5
        包含 A, B, C → 收縮窗口

步驟 2: ADOBEC]ODEBANC
        [DOBEC] 不包含 A → 擴展

步驟 3: ADOBEC[ODEBA]NC
        包含 A, B → 繼續擴展

步驟 4: ADOBECODEBANC]
        [ODEBANC] 不包含全部 → 擴展

步驟 5: ADOBECODE[BANC]
        包含 A, B, C → 找到答案
        長度為 4

最小窗口：BANC</pre>
        </div>
        
        <h2>面試要點</h2>
        <div class="tip-box">
            <h3>解題技巧</h3>
            <ul>
                <li>使用哈希表記錄字符頻率</li>
                <li>formed 變量追蹤匹配進度</li>
                <li>雙指針維護滑動窗口</li>
                <li>先擴展再收縮找最小窗口</li>
            </ul>
        </div>
        
        <div class="tip-box">
            <h3>常見錯誤</h3>
            <ul>
                <li>忘記檢查字符頻率是否完全匹配</li>
                <li>窗口收縮條件判斷錯誤</li>
                <li>邊界情況處理不當</li>
                <li>字符串索引越界</li>
            </ul>
        </div>
    </div></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const lang = this.dataset.lang;
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.code-content').forEach(c => c.classList.remove('active'));
                this.classList.add('active');
                document.querySelector(`.code-content.${lang}`).classList.add('active');
            });
        });
    </script>
</body>
</html>